---
title: "Des mathématiques pour faire rouler les trains"
author: "Guillaume Dalle"
date: "09/10/2025"
institute: Cycle SMAI & Musée des arts et métiers
format:
  revealjs:
    toc: true
    toc-depth: 1
    toc-title: "Table des matières"
    width: 1280
    height: 720
    slide-number: true
    code-fold: true
    title-slide-attributes:
      data-background-image: img/logos/enpc.png
      data-background-size: 25%
      data-background-position: 50% 98%
from: markdown+emoji
engine: julia
bibliography: SMAI.bib
css: style.css
---

# Introduction

## La recherche, c'est quoi ?

Plein de métiers différents à la fois !

:::: {.columns}

::: {.column width="33%"}

- :book: Lire
- :thinking: Réfléchir
- :keyboard: Coder

:::

::: {.column width="33%"}

- :scroll: Écrire
- :microphone: Présenter
- :teacher: Enseigner

:::

::: {.column width="33%"}

- :student: Encadrer
- :open_file_folder: Organiser
- :dollar: Financer

:::

::::

## La recherche en transports

De multiples disciplines mobilisées :

:::: {.columns}

::: {.column}
- :factory: Ingénierie
- :money_mouth_face: Économie
- :world_map: Géographie
:::

::: {.column}
- :people_holding_hands: Sociologie
- :computer: Informatique
- :heavy_plus_sign: Mathématiques ?
:::

::::

## Mon parcours

1. Lycée scientifique
1. Classe préparatoire maths-physique
1. École d'ingénieurs
1. Thèse (_comment prédire et éviter les retards de trains ?_)
1. Postdoctorat (_comment analyser des réseaux complexes ?_)
1. Chercheur (_comment mutualiser les livraisons de marchandises ?_)

## La planification ferroviaire

:::: {.columns}

::: {.column width="40%"}

![Étapes du processus [@schlechteRailwayTrackAllocation2012]](img/papers/planning.png){.lightbox width="80%"}

:::

::: {.column width="60%"}

Acteurs impliqués :

- :bullettrain_side: Entreprises ferroviaires (RU)
- :railway_track: Gestionnaire d'infrastructure (IM)

Échelles temporelles :

- :older_man: Stratégique : A-5
- :calendar: Tactique : A-1 à M-1
- :watch: Opérationnelle : M-1 à J-1

:::

::::

## Focus sur l'allocation d'itinéraires

But : amener chaque train de son point de départ à son point d'arrivée.

![Le challenge Flatland (<https://flatland-association.github.io/>)](img/flatland/animation.gif){.lightbox width="70%"}

Problème d'**optimisation** sur un **graphe**, de **complexité** exponentielle.

# Notions de théorie des graphes

## Définition

:::: {.columns}
::: {.column width="60%"}
Un graphe $G = (N, A)$ est composé

- d'un ensemble de noeuds $i \in N$
- d'un ensemble d'arêtes $a = (i, j) \in A$
:::
::: {.column width="40%"}
```{julia}
using Graphs, CairoMakie, GraphMakie, NetworkLayout, StableRNGs

function plot_graph(g, w=nothing; layout=Spring(), margin=(0.1, 0.1, 0.1, 0.1))
    pos = layout(g)
    x0, x1 = minimum(map(x -> x[1], pos)), maximum(map(x -> x[1], pos))
    y0, y1 = minimum(map(x -> x[2], pos)), maximum(map(x -> x[2], pos))
    elabels = isnothing(w) ? nothing : [string(w[src(e), dst(e)]) for e in edges(g)]
    fig = Figure()
    ax = Axis(fig[1, 1])
    pl = graphplot!(ax, g; layout=_ -> pos, ilabels=collect(1:nv(g)), elabels, ilabels_fontsize=50, elabels_fontsize=40, arrow_shift=:end, arrow_size=isnothing(w) * 40)
    xlims!(ax, x0 - margin[4] * (x1 - x0), x1 + margin[2] * (x1 - x0))
    ylims!(ax, y0 - margin[1] * (y1 - y0), y1 + margin[3] * (y1 - y0))
    hidedecorations!(ax)
    hidespines!(ax)
    return fig
end

plot_graph(SimpleGraph(10, 20; rng=StableRNG(0)))
```

:::
::::

Permet de représenter des connexions entre différentes entités.

## Origines : les 7 ponts de Königsberg

Le premier problème de théorie des graphes fut posé par Euler.

![Peut-on traverser tous ces ponts une fois chacun sans revenir sur ses pas ?](img/graphs/konigsberg.png){.lightbox}

## Applications

:::: {.columns}
::: {.column width="33%"}
- Communications
:::
::: {.column width="33%"}
- Réseaux sociaux
:::
::: {.column width="33%"}
- Molécules / protéines
:::
::::

![Structure de communauté dans un graphe [@abbeCommunityDetectionStochastic2018]](img/graphs/community.png){.lightbox width="70%"}

## Le réseau ferroviaire comme graphe

Un noeud ne correspond pas toujours à une localisation physique !

![Représentation graphique d'un réseau avec orientation [@laurentFlatlandCompetition20202021]](img/flatland/graph.png){.lightbox}

# Notions d'optimisation

## Est-ce de l'IA ?

L'Intelligence Artificielle désigne un ensemble d'algorithmes permettant d'automatiser des tâches typiquement attribuées aux humains.

::::: {.columns}

:::: {.column width="33%"}
::: {.callout-note}
### Prédiction

Anticiper un phénomène inconnu ou futur.
:::
![](img/apps/translate.png){height=250 fig-align="center"}
::::

:::: {.column width="33%"}
::: {.callout-tip}
### Génération

Produire des médias à partir de consignes et d'exemples.
:::
![](img/apps/chatgpt.png){height=250 fig-align="center"}
::::

:::: {.column width="33%"}
::: {.callout-warning}
### Décision

Planifier l'usage de ressources limitées.
:::
![](img/apps/maps.png){height=250 fig-align="center"}
::::

:::::

## Vous apprendrez cette année à résoudre des problèmes d'optimisation

:::: {.columns}
::: {.column width="60%"}
Trouver le minimum d'une fonction $x \in \mathbb{R} \longmapsto f(x)$.

Il suffit de calculer sa dérivée $f'(x)$ (pente de la courbe) et de résoudre $f'(x) = 0$.

Problème : comment fait-on si $x$ doit satisfaire des contraintes ?
:::
::: {.column width="40%"}
```{julia}
x = -4:0.01:4
f(x) = 3cos(x-3) / (x+5)
fig = Figure(size=(600, 600))
ax = Axis(fig[1, 1], xlabel="x", ylabel="f(x)", xlabelsize=50, ylabelsize=50, aspect=1.0)
lines!(ax, x, f.(x), linewidth=8)
fig
```
:::
::::


## Un problème sous contrainte

On me donne une tôle d'aluminium de surface $1 m^2$ pour fabriquer une casserole. Comment obtenir le plus grand volume ?

:::: {.columns}
::: {.column width="50%"}

- La casserole a un rayon $r$ et une hauteur $h$.
- Sa surface est donnée par $S(r, h) = \pi r^2 + 2 \pi r h$.
- Son volume est donné par $V(r, h) = \pi r^2 h$.
:::
::: {.column width="50%"}
Problème d'optimisation :

$$\begin{aligned}\max_{r,h} \quad & V(r, h)  \\ \text{s.c.} \quad & S(r, h) \leq 1  \\ & r \geq 0 \\ & h \geq 0\end{aligned}$$
:::
::::

## Modéliser la réalité

:::: {.columns}
Pour que l'ordinateur aide à la décision, il faut expliciter le problème :

::: {.column width="25%"}
- Données
:::
::: {.column width="25%"}
- Variables
:::
::: {.column width="25%"}
- Contraintes
:::
::: {.column width="25%"}
- Objectif
:::

::::

::: {.callout-important}
### Simplification nécessaire

"Tous les modèles sont faux, mais certains sont utiles." (George Box)
:::

## Données du problème

:::: {.columns}

::: {.column width="35%"}

- Topographie du réseau : un graphe dirigé $G = (N, A)$

- Durée de la journée $T$

:::

::: {.column width="5%"}
:::

::: {.column width="60%"}
- Ensemble $V$ de voyages, chaque voyage $v \in V$ possédant :
  - Station de depart $s_v^d$ et d'arrivée $s_v^a$
  - Heure de départ $h_v^d$ et d'arrivée $h_v^a$ théoriques
:::

::::

## Variables de décision

Itinéraire de chaque voyage : suite de noeuds $(n_v^1, ..., n_v^T)$

Heures d'arrivée et de départ ? Déterminées par les contraintes.

![Décider ce que fait chaque train à chaque intersection [@laurentFlatlandCompetition20202021]](img/flatland/flatland_env_and_transitions.png){.lightbox}

## Contraintes à respecter

- Chaque voyage existe sur le réseau : $(n_v^t, n_v^{t+1}) \in A$
- Chaque voyage part de sa station de départ : $n_v^1 = s_v^d$
- Chaque voyage arrive à sa station d'arrivée : $n_v^T = s_v^a$
- Chaque voyage attend son heure de départ : $n_v^1 = n_v^2 = \dots = n_v^{h_v^d}$
- Deux voyages n'occupent jamais le même noeud en même temps : $n_v^t \neq n_{v'}^t$

## Fonction objectif

Retard d'un voyage :
$$r_v = \max(0, \delta_v) \quad \text{où} \quad \delta_v = \min \{t : n_v^t = s_v^a\} - h_v^a$$

"Coût" à minimiser : plusieurs choix possibles

:::: {.columns}
::: {.column}
- Retard total $\sum_v r_v$
:::
::: {.column}
- Retard maximal $\max_v r_v$
:::
::::

## Résolution

Les problèmes d'optimisation réalistes sont résolus par des algorithmes, implémentés sous forme de code informatique.

Critères d'évaluation :

:::: {.columns}
::: {.column width="50%"}
- :white_check_mark: Terminaison
- :point_right: Correction
:::
::: {.column width="50%"}
- :1st_place_medal: Optimalité
- :runner: Complexité
:::
::::

# Notions de complexité

## Taille de l'entrée & efficacité

:::: {.columns}
::: {.column width="60%"}
Nos données d'entrée se mesurent par : 

- le nombre de noeuds du graphe $N$
- le nombre d'arêtes du graphe $A$
- le nombre de voyages $V$
:::
::: {.column width="40%"}
L'efficacité d'un algorithme se mesure par :

- le temps de calcul
- la mémoire utilisée
:::
::::

Plus l'entrée est grande, plus l'algorithme utilise de ressources.

## Polynomial vs exponentiel

On mesure la complexité en opérations arithmétiques ($+$, $-$, $\times$, $\div$).
Supposons que chacune prend $1$ nanoseconde.

| Complexité | $N = 50$ | $N = 100$ | $N = 200$ 
|---|---|---|---|---|
| "linéaire" ($N$) | 50 ns | 0.1 µs | 0.2 µs
| "quadratique" ($N^2$) | 2.5 µs | 10 µs | 40 ms |
| "cubique" ($N^3$) | 0.1 ms | 1 ms | 8 ms |
| "exponentielle" ($2^N$) | 13 jours | 10$^{13}$ ans | ? |

## Exemples

| Problème | Complexité | Algorithme |
|---|---|---|
| Trouver le minimum d'une liste de nombres | $N$ | Parcours simple |
| Trier une liste de nombres | $N \log N$ | Tri fusion |
| Calculer un seul itinéraire | $N \log N$ | A* |
| Calculer plusieurs itinéraires compatibles | exponentielle | ? |

# Le rôle des benchmarks

## Pourquoi se comparer ?

:::: {.columns}
::: {.column width="35%"}
On sait résoudre des problèmes exponentiels, mais pas toujours exactement.

Benchmark = instances de test standardisées pour évaluer les différentes approches.
:::
::: {.column width="65%"}
![Différentes méthodes de résolution pour Flatland [@laurentFlatlandCompetition20202021]](img/flatland/flatland_score_plot_v3.png){.lightbox}
:::
::::

Nécessite de trouver des points communs entre différents problèmes.

## Simplification 1 : de la réalité à Flatland

:::: {.columns}
::: {.column width="60%"}
Flatland est un problème plus simple que la réalité :

- Réseau assimilé à une grille
- Commande centralisée
- Vitesse constante
- Pas de stations intermédiaires
- Pas de mécanisme de sécurité

:::
::: {.column width="40%"}
![Un paysage suisse bucolique (<https://flatland-association.github.io>)](img/flatland/Flatland_Preview.svg){.lightbox width="80%"}
:::
::::

## Simplification 2 : de Flatland au MAPF

:::: {.columns}
::: {.column width="60%"}
Le _Multi-Agent PathFinding_ est un problème encore plus simple que Flatland :

- Cellules plus simples (vides ou obstacles)
- Les agents sont ponctuels
- Pas d'accidents aléatoires

Très utile pour développer de nouveaux algorithmes !
:::
::: {.column width="40%"}
![Une instance de MAPF à deux agents [@gaoReviewGraphbasedMultiagent2024]](img/mapf/simple.png){.lightbox}
:::
::::

## Le benchmark MAPF

Instances de tailles et natures variées [@sternMultiAgentPathfindingDefinitions2019].

:::: {.columns}
::: {.column width="20%"}
![](img/mapf/Berlin_1_256.svg)
Villes
:::
::: {.column width="20%"}
![](img/mapf/brc202d.svg)
Jeux vidéo
:::
::: {.column width="20%"}
![](img/mapf/maze-32-32-2.svg)
Labyrinthes
:::
::: {.column width="20%"}
![](img/mapf/room-64-64-8.svg)
Pièces
:::
::: {.column width="20%"}
![](img/mapf/random-32-32-20.svg)
Aléatoires
:::
::::

## Comment gagner le challenge Flatland ?

:::: {.columns}
::: {.column width="50%"}
Avec des techniques éprouvées pour un problème plus simple (MAPF) :

1. Recherche d'itinéraire efficace pour un seul train
2. Gestion des conflits pour plusieurs trains

Découvrons la stratégie de l'équipe gagnante !
:::
::: {.column width="50%"}
![Les deadlocks sont un défi majeur [@liScalableRailPlanning2021]](img/flatland/deadlocks.png){.lightbox}
:::
::::

# Itinéraire pour un seul train

## Existe-t-il toujours un plus court chemin ?

:::: {.columns}
::: {.column width="50%"}
Pas si le graphe est déconnecté

```{julia}
g = blockdiag(complete_graph(3), complete_graph(3))
plot_graph(g)
```
:::
::: {.column width="40%"}
Pas si le graphe a des cycles de coût négatif

```{julia}
using SimpleWeightedGraphs
g = SimpleWeightedDiGraph([
  0 1 0 0
  0 0 1 0
  0 -2 0 1
  0 0 0 0
])
plot_graph(g, weights(g))
```
:::
::::

## Recherche en largeur : exploration naïve

Explorer le graphe par cercles concentriques autour du point de départ.

::::: {.columns}

:::: {.column width="50%"}
::: {.callout-tip}
### Avantage

Très facile à appliquer
:::
::::

:::: {.column width="50%"}
::: {.callout-warning}
### Défaut

Exploration à l'aveugle
:::
::::

:::::

[Lien de visualisation](https://tobinatore.github.io/algovis/pathfinding.html)

## Algorithme A* : exploration guidée

Prioriser les sommets selon la somme de deux quantités :

- distance exacte depuis l'origine $g(n)$
- distance _approximative_ jusqu'à la destination $h(n)$

::::: {.columns}

:::: {.column width="50%"}
::: {.callout-tip}
### Avantage

Évite de se disperser
:::
::::

:::: {.column width="50%"}
::: {.callout-warning}
### Défaut

Nécessite une bonne "heuristique"
:::
::::

:::::

[Lien de visualisation](https://tobinatore.github.io/algovis/pathfinding.html)

## Est-ce le meilleur algorithme ?

:::: {.columns}
::: {.column width="50%"}
A* est le meilleur algorithme de sa "famille" si l'heuristique utilisée est :

- admissible : sous-estime toujours le coût du chemin restant
- consistente : satisfait l'inégalité triangulaire $h(j) \leq w(i, j) + h(i)$

Mais on peut faire mieux si on a accès au graphe en avance [@bastRoutePlanningTransportation2016].
:::
::: {.column width="50%"}
![](img/graphs/routing.png)
:::
::::

# Itinéraires pour plusieurs trains

## Une explosion des possibilités

Idéalement, on voudrait trouver les itinéraires pour chaque agent en parallèle.

Plus les agents sont nombreux, plus on dévie du chemin optimal.

[Lien de visualisation](https://tracker.pathfinding.ai/instances?mapId=63761f265d814f08ecdbf3c2&reason=unknown&scenId=63761f275d814f08ecdbfa03&instanceId=637636c25d814f08ecf24266&solutionId=64113b7aa77d79716569426c&source=submitted).

## Recherche arborescente : c'est trop long !

Idée (_Conflict-Based Search_) : dès qu'on rencontre un conflit, explorer les deux possibilités engendrées.

::::: {.columns}

:::: {.column width="60%"}
![Il faut explorer toutes les feuilles de l'arbre [@wangWherePathsCollide2025]](img/mapf/cbs.png){.lightbox}
::::

:::: {.column width="40%"}
::: {.callout-tip}
### Avantage

Trouve une solution optimale
:::
::: {.callout-warning}
### Défaut

Complexité exponentielle
:::
::::

:::::

## Planification priorisée

Idée : planifier les agents un par un, et les considérer comme obstacles figés ensuite.

::::: {.columns}

:::: {.column width="60%"}
![L'ordre de priorité est important [@wangWherePathsCollide2025]](img/mapf/prioritized.png){.lightbox}
::::

:::: {.column width="40%"}
::: {.callout-tip}
### Avantage

Très rapide à exécuter
:::
::: {.callout-warning}
### Défaut

Ne trouve pas forcément de solution (optimale)
:::
::::

:::::

## Recherche à voisinages larges

Quand on a trouvé une solution, on peut l'améliorer itérativement :

- Choisir un ensemble d'agents
- Oublier leurs chemins
- Reconstruire de nouveaux chemins en gardant les autres fixés
- Voir si on a trouvé mieux

# Pour aller plus loin

## Représentation des graphes en mémoire

Plusieurs formats possibles :

- Matrice d'adjacence
- Liste d'adjacence
- Liste d'arêtes

[Lien de visualisation](https://visualgo.net/en/graphds)

## Complexité théorique ou pratique

La complexité théorique ne dit pas tout.

L'efficacité d'un algorithme dépend aussi 

- de l'ordinateur et du processeur utilisé, CPU ou GPU
- du langage de programmation choisi
- des structures de données
- du coût d'accès à la mémoire
- de la taille des caches

## Conclusion

- :vertical_traffic_light: Les maths peuvent servir à décrire et résoudre des problèmes d'optimisation en transport.
- :scream: Certains sont faciles (plus court chemin), d'autres difficiles (Flatland).
- :bar_chart: Simplifier et généraliser le problème permet des approches générales et comparables.
- :melting_face: En pratique, tout est toujours plus compliqué (c'est ça qui est fun).

## Références

::: {#refs}
:::

## Des questions ?

Mon site web pour plus d'infos : <https://gdalle.github.io/>